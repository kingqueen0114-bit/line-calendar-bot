/**
 * Task processor for dev agent
 * Manages task queue and orchestrates the development workflow
 */

import { Firestore } from '@google-cloud/firestore';
import {
  getFileContent,
  getRepoTree,
  createBranch,
  createOrUpdateFile,
  createPullRequest,
  addComment
} from './github.js';
import {
  analyzeIssue,
  generateCode,
  reviewCode,
  generatePRDescription
} from './claude.js';
import {
  sendTaskUpdate,
  sendPRNotification,
  sendErrorNotification
} from './line-reporter.js';

// Initialize Firestore
const db = new Firestore();
const tasksCollection = db.collection('dev-agent-tasks');

/**
 * Add a task to the queue
 */
export async function addTask(task) {
  const docRef = tasksCollection.doc(task.id);
  await docRef.set({
    ...task,
    status: 'pending',
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  });
  return task.id;
}

/**
 * Get the task queue
 */
export async function getTaskQueue() {
  const snapshot = await tasksCollection
    .where('status', 'in', ['pending', 'processing'])
    .orderBy('createdAt', 'asc')
    .limit(20)
    .get();

  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
}

/**
 * Update task status
 */
async function updateTaskStatus(taskId, status, data = {}) {
  const docRef = tasksCollection.doc(taskId);
  await docRef.update({
    status,
    ...data,
    updatedAt: new Date().toISOString()
  });
}

/**
 * Process a single task
 */
export async function processTask(task) {
  console.log(`Processing task: ${task.id} - ${task.title}`);

  try {
    // Update status to processing
    await updateTaskStatus(task.id, 'processing');
    await sendTaskUpdate(task, 'processing', 'å‡¦ç†ã‚’é–‹å§‹ã—ã¾ã—ãŸ');

    // Step 1: Analyze the issue
    await sendTaskUpdate(task, 'analyzing', 'ã‚¤ã‚·ãƒ¥ãƒ¼ã‚’åˆ†æžä¸­...');
    const repoContext = await getRepositoryContext();
    const plan = await analyzeIssue(task, repoContext);
    console.log('Analysis complete:', plan);

    // Check complexity
    if (plan.estimated_complexity === 'high') {
      await sendTaskUpdate(
        task,
        'pending',
        'âš ï¸ è¤‡é›‘ãªã‚¿ã‚¹ã‚¯ã®ãŸã‚æ‰‹å‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æŽ¨å¥¨ã—ã¾ã™\n' +
        `åˆ†æžçµæžœ:\n${plan.analysis}`
      );
      await updateTaskStatus(task.id, 'needs_review', { plan });

      if (task.issueNumber) {
        await addComment(
          task.issueNumber,
          `ðŸ¤– **è‡ªå‹•åˆ†æžãƒ¬ãƒãƒ¼ãƒˆ**\n\n` +
          `ã“ã®ã‚¤ã‚·ãƒ¥ãƒ¼ã¯è¤‡é›‘åº¦ã€Œé«˜ã€ã¨åˆ¤æ–­ã•ã‚Œã¾ã—ãŸã€‚\n\n` +
          `**åˆ†æžçµæžœ:**\n${plan.analysis}\n\n` +
          `**å®Ÿè£…ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ:**\n${plan.approach}\n\n` +
          `**å¤‰æ›´äºˆå®šãƒ•ã‚¡ã‚¤ãƒ«:**\n${plan.files_to_modify.map(f => `- ${f}`).join('\n')}\n\n` +
          `æ‰‹å‹•ã§ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¨æ‰¿èªãŒå¿…è¦ã§ã™ã€‚æ‰¿èªã™ã‚‹å ´åˆã¯ \`@dev-agent approve\` ã¨ã‚³ãƒ¡ãƒ³ãƒˆã—ã¦ãã ã•ã„ã€‚`
        );
      }

      return { status: 'needs_review', plan };
    }

    // Step 2: Get relevant file contents
    await sendTaskUpdate(task, 'analyzing', 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å–å¾—ä¸­...');
    const fileContext = await getFileContents(plan.files_to_modify);

    // Step 3: Generate code
    await sendTaskUpdate(task, 'generating', 'ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆä¸­...');
    const codeChanges = await generateCode(task, fileContext, plan);
    console.log('Code generated:', codeChanges.files?.length, 'files');

    // Step 4: Review generated code
    await sendTaskUpdate(task, 'reviewing', 'ã‚³ãƒ¼ãƒ‰ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¸­...');
    const review = await reviewCode(codeChanges.files, task);

    if (!review.approved) {
      const criticalIssues = review.issues.filter(i => i.severity === 'critical');
      if (criticalIssues.length > 0) {
        throw new Error(
          'Critical issues found in code review: ' +
          criticalIssues.map(i => i.description).join(', ')
        );
      }
      // Log warnings but continue
      console.warn('Review warnings:', review.issues);
    }

    // Step 5: Create branch and commit changes
    await sendTaskUpdate(task, 'creating_pr', 'ãƒ–ãƒ©ãƒ³ãƒã‚’ä½œæˆä¸­...');
    const branchName = `auto/${task.type}/${task.id}`;
    await createBranch(branchName);

    for (const file of codeChanges.files) {
      if (file.action !== 'delete') {
        await createOrUpdateFile(
          file.path,
          file.content,
          codeChanges.commit_message || `${task.type}: ${task.title}`,
          branchName
        );
      }
    }

    // Step 6: Create PR
    const prDescription = await generatePRDescription(task, codeChanges, plan);
    const pr = await createPullRequest(
      `[Auto] ${task.title}`,
      prDescription + '\n\n---\nðŸ¤– Generated by Dev Agent',
      branchName
    );

    // Update task status
    await updateTaskStatus(task.id, 'completed', {
      prNumber: pr.number,
      prUrl: pr.html_url,
      completedAt: new Date().toISOString()
    });

    // Send notifications
    await sendPRNotification(task, pr.html_url, pr.number);

    // Comment on original issue
    if (task.issueNumber) {
      await addComment(
        task.issueNumber,
        `ðŸŽ‰ PR #${pr.number} ã‚’ä½œæˆã—ã¾ã—ãŸ!\n\n` +
        `${pr.html_url}\n\n` +
        `ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ãŠé¡˜ã„ã—ã¾ã™ã€‚`
      );
    }

    return {
      status: 'completed',
      prNumber: pr.number,
      prUrl: pr.html_url
    };

  } catch (error) {
    console.error('Task processing error:', error);

    await updateTaskStatus(task.id, 'failed', {
      error: error.message,
      failedAt: new Date().toISOString()
    });

    await sendErrorNotification(task, error);

    if (task.issueNumber) {
      await addComment(
        task.issueNumber,
        `âŒ è‡ªå‹•å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚\n\n` +
        `**ã‚¨ãƒ©ãƒ¼:** ${error.message}\n\n` +
        `æ‰‹å‹•ã§ã®å¯¾å¿œãŒå¿…è¦ãªå¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚`
      );
    }

    throw error;
  }
}

/**
 * Get repository context for analysis
 */
async function getRepositoryContext() {
  const tree = await getRepoTree('src');
  const structure = tree
    .filter(item => item.type === 'blob')
    .map(item => `- ${item.path}`)
    .join('\n');

  return {
    name: 'line-calendar-bot',
    structure
  };
}

/**
 * Get file contents for context
 */
async function getFileContents(paths) {
  const contents = [];

  for (const path of paths) {
    const content = await getFileContent(path);
    if (content) {
      contents.push({ path, content });
    }
  }

  return contents;
}

/**
 * Get task by ID
 */
export async function getTask(taskId) {
  const doc = await tasksCollection.doc(taskId).get();
  if (!doc.exists) {
    return null;
  }
  return { id: doc.id, ...doc.data() };
}

/**
 * Get task statistics
 */
export async function getTaskStats() {
  const today = new Date().toISOString().split('T')[0];

  const [pending, processing, completed, failed] = await Promise.all([
    tasksCollection.where('status', '==', 'pending').count().get(),
    tasksCollection.where('status', '==', 'processing').count().get(),
    tasksCollection.where('status', '==', 'completed')
      .where('completedAt', '>=', today)
      .count().get(),
    tasksCollection.where('status', '==', 'failed')
      .where('failedAt', '>=', today)
      .count().get()
  ]);

  return {
    pending: pending.data().count,
    processing: processing.data().count,
    completedToday: completed.data().count,
    failedToday: failed.data().count
  };
}

/**
 * Retry a failed task
 */
export async function retryTask(taskId) {
  const task = await getTask(taskId);
  if (!task) {
    throw new Error('Task not found');
  }

  await updateTaskStatus(taskId, 'pending', {
    retryCount: (task.retryCount || 0) + 1
  });

  return task;
}

/**
 * Cancel a pending task
 */
export async function cancelTask(taskId) {
  await updateTaskStatus(taskId, 'cancelled', {
    cancelledAt: new Date().toISOString()
  });
}
